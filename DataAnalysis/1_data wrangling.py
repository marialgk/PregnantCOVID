# -*- coding: utf-8 -*-
"""Copy of data_processing_pipeline_jan2024_for_drive.ipynb

Automatically generated by Colab.

Version: 8

Author: Maria Laura Kuniyoshi

Data: Jan 2024
"""

from datetime import datetime
import numpy as np
import pandas as pd


# Load dataset
df = pd.read_csv('master_table.txt', sep='\t')

# Set the hash as index name
df = df.set_index('hash')

################STANDARDIZE MISSING VALUES REPORTING ##########################

# BOOLEAN COLUMNS
# Boolean columns (sim / não; s / n; yes / no)
bool_col = ['complications_during_preg',
            'lifetime_serious_illness_injury',
            'lifetime_relative_friend_death',
            'lifetime_breakup',
            'lifetime_unemployed',
            'lifetime_fired',
            'lifetime_school_dropout',
            'lifetime_financial_issue',
            'lifetime_move_out_by_choice',
            'lifetime_move_out_no_choice',
            'lifetime_police_court',
            'lifetime_child_protection_service',
            'lifetime_guardianship_loss',
            'lifetime_shelter',
            'lifetime_other_stressful_event',
            'pregnancy_hospital_visit',
            'pregnancy_fight_relative_friend',
            'pregnancy_fight_other_parent',
            'pregnancy_violence',
            'pregnancy_move_out_by_choice',
            'pregnancy_move_out_no_choice',
            'pregnancy_relative_friend_drift_apart',
            'pregnancy_other_stressful_event',
            'delivery_complications',
            'has_sorology',
            'IgG_test_bool'
            ]

new_answers = {-99 : np.nan,
                0 : False,
                3 : True,
                2 : True,
                'não' : False,
                'sim' : True,
                '  Não ': False,
                'N' : False,
                'NÃO ' : False,
                's' : True,
                'S' : True,
                'Sim' : True,
                'Nãox' : False,
                ' nao' : False,
                ' NÃO ' : False,
                'ão' : False,
                'nãox' : False,
                'nao' : False,
                'não se aplica' : np.nan,
                'im' : True,
                'n' : False,
                'sem informação' : np.nan,
                'simx' : True,
                'simxx' : True,
                ' ' : np.nan,
                ' Não   ' : False,
                'Não  ' : False,
                ' Não  ' : False,
                'nã': False,
                ' nao ' : False,
                'não sei' : np.nan,
                'Sim tio do marido' : True,
                'Não' : False,
                ' Não se aplica' : np.nan,
                ' Não se aplica ' : np.nan,
                ' não se aplica ' : np.nan,
                ' Não  se aplica ' : np.nan,
                ' Não se aplica  ' : np.nan,
                'não se aplica ' : np.nan,
                ' Não ' : False,
                ' Sem informação  ' : np.nan,
                ' SEM INFORMAÇÃO ' : np.nan,
                ' FALHOU EOA – vai refazar  ' : np.nan,
                ' Sem informação ' : np.nan,
                'Sim ' : True,
                'não ' : False,
                ' NÃO' : False,
                'Sem informação' : np.nan,
                'NAO' : False,
                1: True,
                '1': True,
                1.0: True,
                'Sim,' : True,
                'NÃ£o' : False,
                'reagente': True,
                'não reagente': False,
                'NR': False,
                '0': False,
                'Não ': False
                }

for i in bool_col:
    df[i] = df[i].replace(new_answers)

# NON-BOOLEAN COLUMNS
# There are still some -99 and equivalent values in non-boolean columns.
# convert them to np.nan

df = df.replace({-99: np.nan,
                 '-99': np.nan,
                 '-': np.nan,
                 '': np.nan,
                 ' ' : np.nan,
                 'NÃ£o' : False,
                 'NR': np.nan})

##################### CONVERT STRING TO NUMERIC COLS ##########################

def str2num(dataframe, colname, dtype='int'):
    return dataframe[colname].str.replace('\D', '').astype(dtype,
                                                           errors='ignore')

############################## REMOVE INVALID VALUES ##########################

# For the weight and height
# Some are in grams, other in kilos.
# Some are abnormally high or low.

def fix_weight(value, maximum=200, minimum=30, divide=1000):
    value = float(value)
    if np.isnan(value):
        return np.nan
    elif value < minimum:
        return np.nan
    elif value < maximum:
        return value
    else:
        return value / divide

df['mom_pregestational_weight'] = df['mom_pregestational_weight'].apply(fix_weight)
df['mom_height'] = df['mom_height'].apply(fix_weight, divide=100)


# REMOVE OUT OF RANGE VALUES

def check_range(df):
    """
    Check if the values are accoring to the data dictionary.

    If it is not accordingly, substitute for NaN.
    """

    valid_scores = {'mom_age' : [i for i in range(13, 70)],
                    'mom_education' : [i for i in range(0, 8)],
                    'Ethinicity' : [i for i in range(0, 4)],
                    'prenatal_appointments_1st_trim' : [i for i in range(0, 4)],
                    'prenatal_appointments_2nd_trim' : [i for i in range(0, 4)],
                    'prenatal_appointments_3rd_trim' : [i for i in range(0, 4)],
                    'complications_during_preg' : [True, False],
                    'STAI_S_calm' : [i for i in range(0, 4)],
                    'STAI_S_secure' : [i for i in range(0, 4)],
                    'STAI_S_tense' : [i for i in range(0, 4)],
                    'STAI_S_regretful' : [i for i in range(0, 4)],
                    'STAI_S_at_ease' : [i for i in range(0, 4)],
                    'STAI_S_upset' : [i for i in range(0, 4)],
                    'STAI_S_misfortunes' : [i for i in range(0, 4)],
                    'STAI_S_rested' : [i for i in range(0, 4)],
                    'STAI_S_anxious' : [i for i in range(0, 4)],
                    'STAI_S_comfortable' : [i for i in range(0, 4)],
                    'STAI_S_self-confident' : [i for i in range(0, 4)],
                    'STAI_S_nervous' : [i for i in range(0, 4)],
                    'STAI_S_jittery' : [i for i in range(0, 4)],
                    'STAI_S_high_strung' : [i for i in range(0, 4)],
                    'STAI_S_relaxed' : [i for i in range(0, 4)],
                    'STAI_S_satisfied' : [i for i in range(0, 4)],
                    'STAI_S_worried' : [i for i in range(0, 4)],
                    'STAI_S_confused' : [i for i in range(0, 4)],
                    'STAI_S_joyful' : [i for i in range(0, 4)],
                    'STAI_S_pleasant' : [i for i in range(0, 4)],
                    'STAI_T_pleasant' : [i for i in range(0, 4)],
                    'STAI_T_I_tire_quickly' : [i for i in range(0, 4)],
                    'STAI_T_like_crying' : [i for i in range(0, 4)],
                    'STAI_T_I_wish_be_happy' : [i for i in range(0, 4)],
                    'STAI_T_cant_make_up_mind' : [i for i in range(0, 4)],
                    'STAI_T_rested' : [i for i in range(0, 4)],
                    'STAI_T_calm_cool_collected' : [i for i in range(0, 4)],
                    'STAI_T_difficulties_are_piling_up' : [i for i in range(0, 4)],
                    'STAI_T_I_worry_too_much' : [i for i in range(0, 4)],
                    'STAI_T_happy' : [i for i in range(0, 4)],
                    'STAI_T_I_take_things_hard' : [i for i in range(0, 4)],
                    'STAI_T_I_lack_self-confidence' : [i for i in range(0, 4)],
                    'STAI_T_secure' : [i for i in range(0, 4)],
                    'STAI_T_I_avoid_crises' : [i for i in range(0, 4)],
                    'STAI_T_blue' : [i for i in range(0, 4)],
                    'STAI_T_satisfied' : [i for i in range(0, 4)],
                    'STAI_T_unimportant_thoughts' : [i for i in range(0, 4)],
                    'STAI_T_I_take_disappointments' : [i for i in range(0, 4)],
                    'STAI_T_steady_person' : [i for i in range(0, 4)],
                    'STAI_T_state_of_tension' : [i for i in range(0, 4)],
                    'lifetime_serious_illness_injury' : [True, False],
                    'lifetime_relative_friend_death' : [True, False],
                    'lifetime_breakup' : [True, False],
                    'lifetime_unemployed' : [True, False],
                    'lifetime_fired' : [True, False],
                    'lifetime_school_dropout' : [True, False],
                    'lifetime_financial_issue' : [True, False],
                    'lifetime_move_out_by_choice' : [True, False],
                    'lifetime_move_out_no_choice' : [True, False],
                    'lifetime_police_court' : [True, False],
                    'lifetime_child_protection_service' : [True, False],
                    'lifetime_guardianship_loss' : [True, False],
                    'lifetime_shelter' : [True, False],
                    'lifetime_other_stressful_event' : [True, False],
                    'pregnancy_hospital_visit' : [True, False],
                    'pregnancy_fight_relative_friend' : [True, False],
                    'pregnancy_fight_other_parent' : [True, False],
                    'pregnancy_violence' : [True, False],
                    'pregnancy_move_out_by_choice' : [True, False],
                    'pregnancy_move_out_no_choice' : [True, False],
                    'pregnancy_relative_friend_drift_apart' : [True, False],
                    'pregnancy_other_stressful_event' : [True, False],
                    'last30d_bothered' : [i for i in range(0, 5)],
                    'last30d_unable_of_control' : [i for i in range(0, 5)],
                    'last30d_nervous' : [i for i in range(0, 5)],
                    'last30d_confident' : [i for i in range(0, 5)],
                    'last30d_unexpected' : [i for i in range(0, 5)],
                    'last30d_manage_tasks' : [i for i in range(0, 5)],
                    'last30d_manage_stress' : [i for i in range(0, 5)],
                    'last30d_everything_under_control' : [i for i in range(0, 5)],
                    'last30d_angry' : [i for i in range(0, 5)],
                    'last30d_piled_up_problems' : [i for i in range(0, 5)],
                    'delivery_complications' : [True, False],
                    'delivery_type' : [i for i in range(0, 4)],
                    'apgar_1min_neonate1' : [i for i in range(0, 11)],
                    'apgar_5min_neonate1' : [i for i in range(0, 11)],
                    'assigned_sex_neonate1' : [0, 1],
                    'COVID-19_sorology' : ['P', 'N'],
                    'has_sorology' : [True, False],
                    }
    for i in valid_scores.items():
        valid_scores[i[0]] = i[1] + [np.nan]

    df = df.T

    for i in df.iterrows():
        # Each i is a tuple with two values.
        # The first is the index.
        # The second is a series of the values.
        invalid = {}
        col = i[1]
        variable = i[0]  # index

        if variable in valid_scores.keys():
            valid_value = col.isin(valid_scores[variable])
            invalid = list(valid_value[valid_value == False].index)

        for mom in invalid:
            print(f'Invalid score for the var {variable}, sample {mom}, value {col[mom]}')
            df.loc[variable, mom] = np.nan

    print('Replaced all invalid or missing scores with NaN')
    return df.T

df = check_range(df)

########################### SECONDARY VARIABLES ###############################

# Stress scales


def EPS10(series):
    variables = ['last30d_bothered',
                 'last30d_unable_of_control',
                 'last30d_nervous',
                 'last30d_confident',
                 'last30d_unexpected',
                 'last30d_manage_tasks',
                 'last30d_manage_stress',
                 'last30d_everything_under_control',
                 'last30d_angry',
                 'last30d_piled_up_problems']
    series = series[variables]

    new_values = {0: 4,
                  1: 3,
                  2: 2,
                  3: 1,
                  4: 0}

    if series.isna().any():
        return np.nan

    for i in ['last30d_confident', 'last30d_unexpected',
              'last30d_manage_stress', 'last30d_everything_under_control']:
        series[i] = new_values[series[i]]

    return series.sum()


def lifetime_stress(series):
    variables = ['lifetime_serious_illness_injury',
                 'lifetime_relative_friend_death',
                 'lifetime_breakup',
                 'lifetime_unemployed',
                 'lifetime_fired',
                 'lifetime_school_dropout',
                 'lifetime_financial_issue',
                 'lifetime_move_out_by_choice',
                 'lifetime_move_out_no_choice',
                 'lifetime_police_court',
                 'lifetime_child_protection_service',
                 'lifetime_guardianship_loss',
                 'lifetime_shelter']
    series = series[variables]

    if series.isna().any():
        return np.nan

    return series.sum()


def preg_stress(series):
    variables = ['pregnancy_hospital_visit',
                 'pregnancy_fight_relative_friend',
                 'pregnancy_fight_other_parent',
                 'pregnancy_violence',
                 'pregnancy_move_out_by_choice',
                 'pregnancy_move_out_no_choice',
                 'pregnancy_relative_friend_drift_apart']
    series = series[variables]

    if series.isna().any():
        return np.nan

    return series.sum()

df['EPS10'] = df.apply(EPS10, axis=1)
df['lifetime_stress_summary'] = df.apply(lifetime_stress, axis=1)
df['pregnancy_stress_summary'] = df.apply(preg_stress, axis=1)



def STAIS(series):
    variable = ['STAI_S_calm',
                'STAI_S_secure',
                'STAI_S_tense',
                'STAI_S_regretful',
                'STAI_S_at_ease',
                'STAI_S_upset',
                'STAI_S_misfortunes',
                'STAI_S_rested',
                'STAI_S_anxious',
                'STAI_S_comfortable',
                'STAI_S_self-confident',
                'STAI_S_nervous',
                'STAI_S_jittery',
                'STAI_S_high_strung',
                'STAI_S_relaxed',
                'STAI_S_satisfied',
                'STAI_S_worried',
                'STAI_S_confused',
                'STAI_S_joyful',
                'STAI_S_pleasant']
    series = series[variable]
    series = series + 1

    new_values = {1: 4,
                  2: 3,
                  3: 2,
                  4: 1}

    if series.isna().any():
        return np.nan

    for i in ['STAI_S_calm',
              'STAI_S_secure',
              'STAI_S_at_ease',
              'STAI_S_rested',
              'STAI_S_comfortable',
              'STAI_S_self-confident',
              'STAI_S_relaxed',
              'STAI_S_satisfied',
              'STAI_S_joyful',
              'STAI_S_pleasant']:
        series[i] = new_values[series[i]]

    return series.sum()


def STAIT(series):
    variable = ['STAI_T_pleasant',
                'STAI_T_I_tire_quickly',
                'STAI_T_like_crying',
                'STAI_T_I_wish_be_happy',
                'STAI_T_cant_make_up_mind',
                'STAI_T_rested',
                'STAI_T_calm_cool_collected',
                'STAI_T_difficulties_are_piling_up',
                'STAI_T_I_worry_too_much',
                'STAI_T_happy',
                'STAI_T_I_take_things_hard',
                'STAI_T_I_lack_self-confidence',
                'STAI_T_secure',
                'STAI_T_I_avoid_crises',
                'STAI_T_blue',
                'STAI_T_satisfied',
                'STAI_T_unimportant_thoughts',
                'STAI_T_I_take_disappointments',
                'STAI_T_steady_person',
                'STAI_T_state_of_tension']
    series = series[variable]
    series = series + 1

    new_values = {1: 4,
                  2: 3,
                  3: 2,
                  4: 1}

    if series.isna().any():
        return np.nan

    for i in ['STAI_T_pleasant',
              'STAI_T_rested',
              'STAI_T_calm_cool_collected',
              'STAI_T_happy',
              'STAI_T_secure',
              'STAI_T_satisfied',
              'STAI_T_steady_person']:
        series[i] = new_values[series[i]]

    return series.sum()

df['STAIS'] = df.apply(STAIS, axis=1)
df['STAIT'] = df.apply(STAIT, axis=1)

## BMI

def BMI(series, weight_col):
    weight = series[weight_col]
    height = series['mom_height']

    if pd.Series([weight, height]).isna().any():
        return np.nan
    else:
        return weight / ((height/100)**2)

df['prenatal_bmi'] = df.apply(BMI, 
                              weight_col='mom_pregestational_weight',
                              axis=1)


# Convert non-ordinal categorical data into binary data
def binarify_cols(df,
                  col,
                  new_names):
    """
    Takes non-ordinal categorical columns and transform them into binary
    columns. There will be one new column for every possible value.
    """
    # One hot encode
    result = pd.get_dummies(df[col], dummy_na=True)

    # Rename columns
    result = result.rename(columns=new_names)

    # Highlight missing data.
    result[result[np.nan] == 1] = np.nan
    result = result.drop(columns=[np.nan])

    # Merge the new columns with the old df.
    new_df = pd.concat([df, result], axis=1)

    return new_df

df = binarify_cols(df,
                   'Ethinicity',
                   {0:'race_white_bool',
                    1:'race_black_bool',
                    2:'race_parda_bool',
                    3:'race_yellow_bool'})

df  = binarify_cols(df,
                    'delivery_type',
                    {0:'vaginal',
                     1:'cesarean',
                     2:'forceps'})


# Binarify work

# The column "Profession" is categorical, with too many categories. I want to 
#change it to "works" or "do not work / homemaker":
    # True: Works
    # False: Homemaker or unemployed


def works(series):
  work = series['Profession']
  if work in ['Dona de casa',
              'NÃ£o tem',
              'Sem ocupaÃ§Ã£o',
              'Do lar',
              np.nan]:
    return False
  else:
    return True

df['works'] = df.apply(works, axis=1)


# RECODE RACE

def marginalized(series):
    """
    I recoded race.

    Raw data: 1 nonordinal categorical variable. 0 = branca, 1 = preta;
    2 = parda; 3 = amarela (não tem opção de indígena).

    After data preprocessing: 4 boolean variables.
    White: yes / no; black: yes / no; etc

    The first one is unfit for the machine learning, they would interpret 
    "parda" as an intermediate value between asian and white.

    The second one is too many variables, I want to reduce.
    So I opted for dividing into marginalized and non-marginalized groups.
    I didn't think that the Ethinic identity would say much about genetic
    ancestrality, not in an admixed country as Brazil. I've read some papers on
    how minority ethnicities are more susceptible to covid:
        https://doi.org/10.1016/j.eclinm.2020.100404
        https://doi.org/10.1007%2Fs40615-021-01170-w
    """
    if series['race_white_bool'] == 1 or series['race_yellow_bool'] == 1:
        return 0
    else:
        return 1

df['race_marginalized_group'] = df.apply(marginalized, axis=1)


# SUM PRENATAL APPOINTMENTS

def sum_appointments(series):
    appointments = series[['prenatal_appointments_1st_trim',
                           'prenatal_appointments_2nd_trim',
                           'prenatal_appointments_3rd_trim']]
    if pd.notna(appointments).all():
        return sum(appointments)
    else:
        return np.nan

df['prenatal_appointments_sum'] = df.apply(sum_appointments, axis=1)


######################## DETECT OUTLIER DELIVERY DATES ########################

def check_delivery_range(series, start='01/03/2021', end='31/03/2022'):
    """
    Checks if delivery date is within the sample collection range.
    If not, returns NAN.

    Input: pandas series. Start and end dates in string in the format %d/%m/%Y.

    Output: pandas series.
    """
    try:
        delivery = datetime.strptime(series['delivery_date'], '%d/%m/%Y')
    except (TypeError, ValueError):
        series['delivery_date'] = np.nan
        return series

    start = datetime.strptime(start, "%d/%m/%Y")
    end = datetime.strptime(end, "%d/%m/%Y")
    if start <= delivery <= end:
        return series
    else:
        print(f'Wrong date: {delivery}, {series.name}')
        series['delivery_date'] = np.nan
        return series

df = df.apply(check_delivery_range,
              axis=1,
              start='01/01/2021',
              end='01/07/2022')

######################### ASSIGN TO COVID GROUPS ##############################

# This study considered whehter the patient had previous COVID-19 infection
# or not.

# For this, we used two immunoassays:
    # 1 - Immunoassay general for anti-SARS-CoV-2 antibodies. If positive, 
        # the patient has had COVID or effective vaccine. If negative, they 
        # have not been infected or effectively vaccinated and thus are from
        # the CONTROL group.
    # 2 - Immunoassay specific to nucleocapsid antibodies. If positive, the
        # antibodies are due to COVID-19 disease or Coronavac vaccine. If
        # negative, there was unnefective immunization or an error in immuno
        # assay, so we discard.
# In the case of positive specific immunoassay, we evaluated the patient's
# vaccination history to account for Coronavac immunisation.

def vaccine_relative_delivery(series, dose):
    """
    Calculates the difference in days between vaccine date and delivery date.
    Negative if the vaccine was before delivery.
    Positive if the vaccine was after delivery.

    Input: pandas series.
           Dose is one of the following strings: 1st, 2nd, 3rd, 4th.

    Output: integer.
    """
    # Delivery date
    try:
        delivery = datetime.strptime(series['delivery_date'], '%d/%m/%Y')
    except (TypeError, ValueError):
        return np.nan

    # Vaccine date
    varname = f'{dose}_shot_covid_date'
    vac_date = str(series[varname]).replace(' ', '')

    try:
        vac_date = datetime.strptime(vac_date, '%d/%m/%Y')
    except (TypeError, ValueError):
        return np.nan

    # Calculate difference
    delta = vac_date - delivery
    return delta.days

for i in ['1st', '2nd', '3rd', '4th']:
    df[f'{i}_covid_vac_days_to_delivery'] = df.apply(vaccine_relative_delivery,
                                                     dose=i,
                                                     axis=1)

def assign_group(series):
  """
  Assigns patient to COVID or NOT-COVID group.

  Input: Pandas series, corresponding to a patient line.
  Output: String.
  """

  # Take important variables
  sorl = series['COVID-19_sorology']
  igg  = series['IgG_test_bool']
  nvac = series['covid_vaccine_n_doses']
  vacs = list(series[['1st_shot_covid_type',
                      '2nd_shot_covid_type',
                      '3rd_shot_covid_type',
                      '4th_shot_covid_type']])
  date = series[['1st_covid_vac_days_to_delivery',
                 '2nd_covid_vac_days_to_delivery',
                 '3rd_covid_vac_days_to_delivery',
                 '4th_covid_vac_days_to_delivery']]

  # A) If sorology is positive: proceed
  if sorl == 'P':
    # B) If IgG test unavailable: DISCARD
    if pd.isna(igg):
      return np.nan
    # B) If IgG test negative: DISCARD
    elif igg == False:
      return np.nan
    # B) If IgG test positive: proceed
    elif igg == True:
      # C) If vaccine data unavailable: DISCARD
      if pd.isna(nvac):
        return np.nan
      # C) If took coronavac: proceed
      elif 'coronavac' in vacs:
        first_cvac = vacs.index('coronavac')
        first_cvac = list(date)[first_cvac]
        # D) If taken after delivery: COVID
        if first_cvac > 0:
          return 'COVID'
        # D) If taken before pregnancy or unknown: DISCARD
        else:
          return np.nan
      # C) If took any other vaccine: proceed
      else:
        # D) If there is vaccine date information: COVID
        if date.any():
          return 'COVID'
        # D) If there is no date information: DISCARD
        else:
          return np.nan
  # A) If sorology is negative: CONTROL
  elif sorl == 'N':
    return 'CONTROL'
  # A) If sorology unavailable: DISCARD
  else:
    return np.nan

df['group'] = df.apply(assign_group, axis=1)

